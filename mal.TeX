\documentclass[11pt, a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage[turkish]{babel}
\usepackage{geometry}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage[svgnames]{xcolor}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{color}
\usepackage{titlesec}
\usepackage{parskip}
\usepackage{enumitem}

% Geometri ayarları
\geometry{a4paper, left=2.5cm, right=2.5cm, top=2.5cm, bottom=2.5cm}

% Başlık formatı
\titleformat{\section}
  {\normalfont\Large\bfseries\color{DarkBlue}}{\thesection}{1em}{}
\titleformat{\subsection}
  {\normalfont\large\bfseries\color{DarkSlateGray}}{\thesubsection}{1em}{}
\titleformat{\subsubsection}
  {\normalfont\normalsize\bfseries\color{DimGray}}{\thesubsubsection}{1em}{}

% Listings ayarları (kod blokları için yeni stil)
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{backcolour}{rgb}{0.98,0.98,0.98} % Çok çok hafif gri arka plan

\lstdefinestyle{csharpstyle}{ % C# için bir stil tanımlıyoruz
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{Green},
    keywordstyle=\color{Blue}, % Anahtar kelimeler mavi
    stringstyle=\color{Red},  % Stringler kırmızı
    basicstyle=\footnotesize\ttfamily, % Kod yazı tipi ve boyutu
    breakatwhitespace=false,         
    breaklines=true,                 % Satırları otomatik böl
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    % Satır numaraları solda
    numbersep=5pt,                   % Numara ile kod arası boşluk
    numberstyle=\tiny\color{codegray}, % Numara stili (küçük, gri)
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=4,                       % Tab boşluğu
    language=C#,                     % Dil olarak C# belirtiyoruz
    frame=single,                    % Basit bir çerçeve
    framerule=0pt,                   % Çerçeve çizgisini görünmez yap (boşluk kalsın)
    rulecolor=\color{black},
    xleftmargin=1em                  % Soldan hafif boşluk
}
\lstset{style=csharpstyle} % Tanımlanan stili varsayılan yap

% Hyperlink ayarları
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=teal, 
    pdftitle={Destek Sistemi Kod Açıklaması (Detaylı)},
    pdfpagemode=UseOutlines, 
    linktoc=all 
}

% Türkçe karakterler için
\usepackage{textcomp} 
\DeclareUnicodeCharacter{00A0}{~} 

\title{Destek Sistemi Backend Kod Açıklaması \\ \Large Uygulama Katmanı - Adım Adım}
\author{AI Pair Programmer (Detaylı Anlatım)}
\date{\today}

\begin{document}
\maketitle
\tableofcontents % İçindekiler tablosu
\newpage

\section{Giriş: Ne Yapıyoruz ve Neden?}

Merhaba! Bu dokümanda, yazdığımız bir bilgisayar programının belirli bir bölümünü, yani \texttt{SupportRequestManagement.Application} katmanını adım adım inceleyeceğiz. Amacım, her şeyi en basit haliyle, sanki ilk defa görüyormuşsun gibi anlatmak.

\subsection{Backend (Arka Uç) Nedir?}

Bir web sitesine girdiğinde veya telefonda bir uygulama kullandığında gördüğün her şey (yazılar, resimler, düğmeler) \textbf{ön uç (frontend)} olarak adlandırılır. Peki, bir düğmeye bastığında ne olur? İşte o zaman işin içine \textbf{arka uç (backend)} girer.

Arka uç, göremediğimiz ama işin mutfağıdır:
\begin{itemize}
    \item Bilgileri alır (örn: doldurduğun bir form).
    \item Bu bilgileri işler (örn: hesaplama yapar, kuralları kontrol eder).
    \item Bilgileri bir yere kaydeder (buna \textbf{veritabanı} denir).
    \item Ön uca bir cevap gönderir ("İşlem tamamlandı!", "Şu bilgiler bulundu." gibi).
\end{itemize}
Biz şu anda bu projenin \textbf{arka uç} kodunu yazıyoruz.

\subsection{Application Katmanı Ne İşe Yarar?}

Yazdığımız arka uç kodunu daha düzenli tutmak için katmanlara ayırırız. \textbf{Application (Uygulama) Katmanı} bu katmanlardan biridir ve görevi şudur:
\begin{itemize}
    \item Ön uçtan veya başka sistemlerden gelen istekleri (komutları veya soruları) almak.
    \item Bu isteklerle ilgili temel iş kurallarını ve mantığını çalıştırmak.
    \item Gerekirse diğer katmanlarla (örn: veritabanına erişim için) konuşmak.
    \item Sonucu (cevabı) isteği gönderen yere iletmek.
\end{itemize}
Kısacası, Application katmanı projenin "beyni" gibi düşünebiliriz; istekleri alır, düşünür, işler ve cevap verir.

\subsection{CQRS: İşleri Ayırmak Neden İyi?}

Kodumuzu daha anlaşılır ve yönetilebilir yapmak için \textbf{CQRS (Command Query Responsibility Segregation)} adında bir yöntem kullanıyoruz. Korkutucu ismine aldanma, mantığı çok basit:

\begin{itemize}
    \item \textbf{Command (Komut):} Sistemin durumunu değiştiren isteklerdir. \emph{Örnek: "Yeni kullanıcı ekle", "Şu destek talebini kapat", "Bu yorumu sil".} Bunlar bir eylem gerçekleştirir.
    \item \textbf{Query (Sorgu):} Sistemden sadece bilgi alan isteklerdir. \emph{Örnek: "Bana Ali kullanıcısının bilgilerini ver", "Tüm açık destek taleplerini listele", "Şu talebin yorumlarını göster".} Bunlar sadece veri okur, bir şeyi değiştirmez.
\end{itemize}
CQRS diyor ki, bu iki tür işi (Komut ve Sorgu) birbirinden ayıralım. Neden? Çünkü bir şeyi \textbf{yapmak} ile bir şeyi \textbf{sormak} genellikle farklı adımlar ve kontroller gerektirir. Bunları ayırınca kodumuz daha temiz olur, bir değişiklik yapmak istediğimizde sadece ilgili kısmı düzeltmemiz yeterli olur.

\subsection{Yardımcı Araçlarımız: MediatR, AutoMapper, Repository}

Bu CQRS yapısını kurarken işimizi kolaylaştıran bazı "yardımcı araçlar" (kütüphaneler) kullanıyoruz:

\begin{itemize}
    \item \textbf{MediatR (Postacı):} Gelen bir Komut veya Sorgu isteğini alır ve onu işleyecek olan doğru "Handler" (İşleyici) sınıfına postalar gibi iletir. Biz sadece "isteği gönder" deriz, MediatR doğru kişiyi bulur ve isteği ona verir. Bu sayede kodumuzun farklı parçaları birbirine çok sıkı bağlanmaz.
    \item \textbf{AutoMapper (Tercüman):} Program içinde veriler farklı şekillerde (farklı sınıflar halinde) bulunabilir. Mesela, veritabanında çok detaylı bir `User` bilgisi tutarken, dışarıya sadece `UserDto` olarak ad, email gibi temel bilgileri vermek isteyebiliriz. AutoMapper, bu `User` nesnesini `UserDto` nesnesine otomatik olarak çevirir. Biz sadece hangi nesnenin hangisine çevrileceğini başta bir kere söyleriz, gerisini o halleder.
    \item \textbf{Repository Pattern (Kütüphaneci):} Veritabanı ile doğrudan konuşmak yerine, "Repository" adını verdiğimiz aracı sınıflarla konuşuruz. Biz Application katmanında, "Bana şu ID'li kullanıcıyı ver" isteğimizi Repository'e (kütüphaneciye) söyleriz. Repository gider veritabanından (kütüphaneden) o kullanıcıyı bulur ve bize getirir. Bu sayede, eğer ileride veritabanı sistemimizi değiştirirsek (örn: SQL Server'dan başka bir şeye geçersek), sadece Repository'nin içini değiştirmemiz gerekir, Application katmanındaki kodumuz büyük ölçüde aynı kalır. Biz sadece kütüphanecinin \emph{ne yapabildiğini} (arayüzünü) biliriz, \emph{nasıl yaptığını} bilmemize gerek kalmaz.
\end{itemize}

\section{Klasör Yapısını Anlamak}

Şimdi kodumuza bakalım. \texttt{SupportRequestManagement.Application} klasörünün içinde bir \texttt{Features} klasörü var. Bu, projenin ana işlevsel bölümlerini temsil eder. Biz şu an üç ana bölümle ilgileniyoruz:
\begin{itemize}
    \item \texttt{User}: Kullanıcılarla ilgili işlemler (ekleme, bulma, güncelleme).
    \item \texttt{SupportType}: Destek taleplerinin tipleri (örn: "Yazılım", "Donanım").
    \item \texttt{SupportRequestComment}: Destek taleplerine yapılan yorumlar.
\end{itemize}

Bu klasörlerin her birinin içinde genellikle şu dört alt klasör bulunur:

\begin{description}
    \item[\texttt{Dtos}] (Data Transfer Objects - Veri Taşıma Nesneleri): Bu özelliğe özel, sadece veri taşımak için kullanılan basit sınıflardır. İçlerinde karmaşık iş mantığı olmaz, sadece verinin kendisi bulunur (property'ler).
    \item[\texttt{Commands}] (Komutlar): Bu özellikle ilgili, sistemin durumunu değiştirecek olan istekleri temsil eden sınıflardır (örn: \texttt{CreateUserCommand}).
    \item[\texttt{Queries}] (Sorgular): Bu özellikle ilgili, sistemden bilgi almayı amaçlayan istekleri temsil eden sınıflardır (örn: \texttt{GetUserByIdQuery}).
    \item[\texttt{Handlers}] (İşleyiciler): Yukarıdaki \texttt{Commands} ve \texttt{Queries}'leri alıp, asıl iş mantığını çalıştıran, Repository'ler ve diğer servislerle konuşan sınıflardır (örn: \texttt{CreateUserCommandHandler}). MediatR (postacımız), isteği doğru Handler'a iletir.
\end{description}

Bu temel bilgilerle artık her bir özelliği ve içindeki kodları daha detaylı incelemeye hazırız. İlk olarak \texttt{User} (Kullanıcı) özelliği ile başlayacağız.

\newpage % Yeni sayfaya geç

\section{Özellik 1: User (Kullanıcı İşlemleri)}

Bu bölüm, sistemimizdeki kullanıcı hesaplarını yönetmek için yazdığımız kodları açıklar. Yeni bir kullanıcı oluşturmak, var olan bir kullanıcının bilgilerini değiştirmek, bir kullanıcıyı silmek veya belirli kullanıcıları arayıp bulmak gibi işlemler bu özelliğin sorumluluğundadır.

\subsection{Adım 1: User DTO - Veri Taşıma Kutucuğu (\texttt{UserDto.cs})}

İlk olarak \texttt{Features/User/Dtos} klasörünün içindeki \texttt{UserDto.cs} dosyasına bakalım. \textbf{DTO (Data Transfer Object)}, basitçe "Veri Taşıma Nesnesi" demektir. Yani, farklı kod katmanları arasında veya programımızdan dışarıya (örneğin bir web arayüzüne) kullanıcı bilgilerini taşımak için kullandığımız bir "kutucuktur".

Neden direkt veritabanındaki \texttt{User} nesnesini kullanmıyoruz da \texttt{UserDto} diye ayrı bir sınıf tanımlıyoruz? İki ana sebebi var:

\begin{enumerate}
    \item \textbf{Güvenlik:} Veritabanındaki asıl \texttt{User} nesnesinde kullanıcının şifresinin karmaşıklaştırılmış (hash'lenmiş) hali gibi hassas bilgiler bulunur. Bu tür bilgileri programın dışına göndermek veya her katmanda taşımak istemeyiz. \texttt{UserDto}'ya sadece dışarıyla paylaşılması \textbf{güvenli} olan bilgileri koyarız.
    \item \textbf{İhtiyaç Odaklı Veri:} Bazen dışarıya göndermek istediğimiz veri, veritabanındaki yapıyla tam olarak aynı olmayabilir. DTO sayesinde veriyi tam olarak istediğimiz şekle sokabiliriz.
\end{enumerate}

İşte \texttt{UserDto} sınıfının içeriği:

\begin{lstlisting}[language=C#]
using SupportRequestManagement.Domain.Enums; // UserRole için bu satır gerekli
using System;

namespace SupportRequestManagement.Application.Features.User.Dtos
{
    public class UserDto // "public" demek, bu sınıfa başka yerlerden erişilebilir demek
    {
        // "get; set;" bu bilginin hem okunabileceği hem de yazılabileceği anlamına gelir
        
        public int Id { get; set; } // Kullanıcının sistemdeki benzersiz numarası (kimlik numarası gibi)
        public string Username { get; set; } // Kullanıcının seçtiği kullanıcı adı
        public string Email { get; set; } // Kullanıcının e-posta adresi
        
        // UserRole, kullanıcının sistemdeki yetki seviyesini belirtir.
        // Bu bir "Enum" yani numaralandırılmış bir tiptir (User=0, Admin=1 gibi)
        public UserRole Role { get; set; } 
        
        public DateTime CreatedAt { get; set; } // Hesabın oluşturulduğu tarih ve saat
        
        // Soru işareti (?) bu bilginin "olmayabileceği" anlamına gelir (null olabilir)
        // Kullanıcı hiç giriş yapmamışsa bu değer null olur.
        public DateTime? LastLogin { get; set; } // En son giriş yaptığı tarih ve saat
    }
}
\end{lstlisting}

Dikkat edersen, bu \texttt{UserDto} sınıfının içinde kullanıcının şifresiyle ilgili hiçbir bilgi \textbf{yoktur}. Bu bilinçli bir tercihtir, çünkü şifre gibi hassas bilgileri bu şekilde ortalıkta taşımamalıyız.

\subsection{Adım 2: User Commands - Sisteme Ne Yapacağını Söylemek}
\nYorum işlemleri için genellikle en temel ihtiyaç yeni bir yorum eklemektir. Yorumları güncellemek veya silmek daha az yaygındır ve genellikle özel kurallar (örn: sadece admin silebilir, sadece belirli bir süre içinde güncellenebilir) gerektirir. Bu nedenle, bu aşamada sadece yorum ekleme komutunu (\texttt{CreateSupportRequestCommentCommand}) ele alacağız.

\subsubsection{Yeni Yorum Ekleme İsteği: \texttt{CreateSupportRequestCommentCommand.cs}}
\nBu sınıf, \"Belirtilen destek talebine şu kullanıcı tarafından şu yorumu ekle!\" komutunu temsil eder.

\begin{lstlisting}[language=C#]
using MediatR;
using SupportRequestManagement.Application.Features.SupportRequestComment.Dtos; // Dönecek cevap tipi

namespace SupportRequestManagement.Application.Features.SupportRequestComment.Commands
{
    // Bu komut işlendikten sonra, yeni eklenen yorumun bilgilerini içeren
    // bir SupportRequestCommentDto nesnesi döndürülmesini bekliyoruz.
    public class CreateSupportRequestCommentCommand : IRequest<SupportRequestCommentDto>
    {
        // Yorumun hangi destek talebine ait olduğunu bilmemiz gerekiyor.
        // Bu bilgi dışarıdan (genellikle kullanıcının baktığı talep sayfasından) gelir.
        public int SupportRequestId { get; set; }
        
        // Yorumu kimin yaptığını bilmemiz gerekiyor.
        // Bu bilgi genellikle sisteme o an giriş yapmış olan (authenticated)
        // kullanıcının ID'sinden alınır.
        public int UserId { get; set; }
        
        // Yorumun içeriği. Boş olmamalı (Bu kontrol Handler'da yapılabilir
        // veya buraya [Required] Attribute'u eklenebilir).
        public string Comment { get; set; }
        
        // Eklenen yorumun bir yönetici yorumu mu yoksa kullanıcı yorumu mu
        // olduğunu belirtmek için kullanılır. Bu bilgi de komutla gelmelidir.
        public bool IsAdminComment { get; set; }
    }
}
\end{lstlisting}

\subsection{Adım 3: SupportRequestComment Queries - Yorumları Listeleme}
\nYorumlarla ilgili en yaygın sorgu, belirli bir destek talebine ait tüm yorumları görmektir.

\subsubsection{Talebe Göre Yorumları Getirme Sorgusu: \texttt{GetCommentsBySupportRequestIdQuery.cs}}
\nBu sınıf, \"Bana şu ID'li destek talebine yazılmış tüm yorumların listesini getir.\" sorgusunu temsil eder.

\begin{lstlisting}[language=C#]
using MediatR;
using SupportRequestManagement.Application.Features.SupportRequestComment.Dtos; // Liste dönecek
using System.Collections.Generic; // List<T> için
using System; // ArgumentException için

namespace SupportRequestManagement.Application.Features.SupportRequestComment.Queries
{
    // Bu sorgu işlendikten sonra geriye SupportRequestCommentDto'lardan oluşan
    // bir liste (List<SupportRequestCommentDto>) dönmesini bekliyoruz.
    public class GetCommentsBySupportRequestIdQuery : IRequest<List<SupportRequestCommentDto>>
    {
        // Sorgunun çalışması için hangi destek talebinin yorumlarını istediğimizi
        // bilmemiz gerekiyor. Bu bilgi ID ile temsil edilir.
        public int SupportRequestId { get; set; }
        
        // İLERİ SEVİYE NOTU: Eğer bir talepte çok fazla yorum olması bekleniyorsa
        // (örn: 100'den fazla), tümünü tek seferde getirmek yerine sayfalama
        // yapmak daha iyi olabilir. O zaman buraya PageNumber ve PageSize
        // parametreleri eklenebilir:
        // public int PageNumber { get; set; } = 1;
        // public int PageSize { get; set; } = 20; // Her sayfada 20 yorum

        // Yapıcı metot (constructor) ile talep ID'sini zorunlu olarak alıyoruz.
        public GetCommentsBySupportRequestIdQuery(int supportRequestId)
        {
            // Küçük bir kontrol: Gelen ID'nin geçerli olup olmadığını kontrol etmek
            // (0 veya negatif olmaması) iyi bir alışkanlıktır.
            if (supportRequestId <= 0) 
                throw new ArgumentException("Geçerli bir destek talebi ID'si gereklidir.", nameof(supportRequestId));
                
            SupportRequestId = supportRequestId;
        }
    }
}
\end{lstlisting}

\subsection{Adım 4: SupportRequestComment Handlers - İstekleri İşleme}
\nŞimdi de yorum ekleme komutunu ve yorum listeleme sorgusunu işleyecek olan Handler sınıflarını inceleyelim.

\subsubsection{Yeni Yorum Ekleme İşleyicisi: \texttt{CreateSupportRequestCommentCommandHandler.cs}}
\nBu handler, \texttt{CreateSupportRequestCommentCommand} isteğini alır, gerekli kontrolleri yapar, yorumu veritabanına ekler ve eklenen yorumun bilgilerini (\texttt{SupportRequestCommentDto}) olarak döndürür.

\begin{lstlisting}[language=C#]
using AutoMapper;
using MediatR;
using SupportRequestManagement.Application.Features.SupportRequestComment.Commands;
using SupportRequestManagement.Application.Features.SupportRequestComment.Dtos;
using SupportRequestManagement.Domain.Entities; // Comment entity
using SupportRequestManagement.Domain.Interfaces; // Repositories
using System;
using System.Threading;
using System.Threading.Tasks;
// Bildirim için: using SupportRequestManagement.Application.Features.Notification.Commands;

namespace SupportRequestManagement.Application.Features.SupportRequestComment.Handlers
{
    // Sınıf tanımı: "Ben CreateSupportRequestCommentCommand işlerim ve SupportRequestCommentDto döndürürüm."
    public class CreateSupportRequestCommentCommandHandler : IRequestHandler<CreateSupportRequestCommentCommand, SupportRequestCommentDto>
    {
        // --- İhtiyaçlar (Dependencies) ---
        private readonly ISupportRequestCommentRepository _commentRepository; 
        private readonly ISupportRequestRepository _supportRequestRepository; 
        private readonly IUserRepository _userRepository; 
        private readonly IMapper _mapper; 
        // private readonly IMediator _mediator; 

        // --- Yapıcı Metot (Constructor) ---
        public CreateSupportRequestCommentCommandHandler(
            ISupportRequestCommentRepository cRepo, ISupportRequestRepository sRepo, 
            IUserRepository uRepo, IMapper mapper /*, IMediator mediator */)
        {
            _commentRepository = cRepo ?? throw new ArgumentNullException(nameof(cRepo));
            _supportRequestRepository = sRepo ?? throw new ArgumentNullException(nameof(sRepo));
            _userRepository = uRepo ?? throw new ArgumentNullException(nameof(uRepo));
            _mapper = mapper ?? throw new ArgumentNullException(nameof(mapper));
            // _mediator = mediator;
        }

        // --- Esas İşlem Metodu: Handle ---
        public async Task<SupportRequestCommentDto> Handle(CreateSupportRequestCommentCommand request, CancellationToken cancellationToken)
        {
            // === ADIM 1: Girdi Kontrolleri (Validasyon) ===
            var supportRequest = await _supportRequestRepository.GetByIdAsync(request.SupportRequestId);
            if (supportRequest == null) throw new KeyNotFoundException("Destek talebi bulunamadı.");

            // === ADIM 2: Kullanıcı Kontrolü ===
            var user = await _userRepository.GetByIdAsync(request.UserId);
            if (user == null) throw new KeyNotFoundException("Kullanıcı bulunamadı.");
            
            // === ADIM 3: Yorum Boş Kontrolu ===
            if (string.IsNullOrWhiteSpace(request.Comment)) 
                throw new ArgumentException("Yorum boş olamaz.", nameof(request.Comment));

            // === ADIM 4: İsteği Entity'ye Çevirme ===
            var comment = _mapper.Map<Domain.Entities.SupportRequestComment>(request);
            comment.CreatedAt = DateTime.UtcNow; 

            // === ADIM 5: Veritabanına Kaydetme ===
            await _commentRepository.AddAsync(comment);

            // === ADIM 6: DTO Hazırlığı ===
            var commentDto = _mapper.Map<SupportRequestCommentDto>(comment);
            commentDto.Username = user.Username; 

            // === ADIM 7: Sonucu Döndürme ===
            return commentDto;
        }
    }
}
\end{lstlisting}

\subsubsection{Talebe Göre Yorumları Getirme İşleyicisi: \texttt{GetCommentsBySupportRequestIdQueryHandler.cs}}
\nBu handler, \texttt{GetCommentsBySupportRequestIdQuery} sorgusunu alır, ilgili talebin tüm yorumlarını bulur, yorumları yapan kullanıcıların adlarını ekler ve sonucu \texttt{List<SupportRequestCommentDto>} olarak döndürür.

\begin{lstlisting}[language=C#]
using AutoMapper;
using MediatR;
using SupportRequestManagement.Application.Features.SupportRequestComment.Dtos;
using SupportRequestManagement.Application.Features.SupportRequestComment.Queries;
using SupportRequestManagement.Domain.Interfaces;
using System;
using System.Collections.Generic;
using System.Linq; // Select, Distinct, ToDictionary, Any
using System.Threading;
using System.Threading.Tasks;

namespace SupportRequestManagement.Application.Features.SupportRequestComment.Handlers
{
    // Sınıf tanımı: "GetCommentsBySupportRequestIdQuery işlerim ve List<SupportRequestCommentDto> döndürürüm."
    public class GetCommentsBySupportRequestIdQueryHandler : IRequestHandler<GetCommentsBySupportRequestIdQuery, List<SupportRequestCommentDto>>
    {
        private readonly ISupportRequestCommentRepository _commentRepository;
        private readonly IUserRepository _userRepository;
        private readonly IMapper _mapper;

        public GetCommentsBySupportRequestIdQueryHandler(
            ISupportRequestCommentRepository cRepo, IUserRepository uRepo, IMapper mapper)
        {
            _commentRepository = cRepo ?? throw new ArgumentNullException(nameof(cRepo));
            _userRepository = uRepo ?? throw new ArgumentNullException(nameof(uRepo));
            _mapper = mapper ?? throw new ArgumentNullException(nameof(mapper));
        }

        public async Task<List<SupportRequestCommentDto>> Handle(GetCommentsBySupportRequestIdQuery request, CancellationToken ct)
        {
            // 1. Yorumları getir
            var comments = await _commentRepository.GetBySupportRequestIdAsync(request.SupportRequestId);

            // 2. Yorum yoksa boş liste dön
            if (comments == null || !comments.Any())
            {
                return new List<SupportRequestCommentDto>();
            }

            // 3. Benzersiz kullanıcı ID'lerini topla
            var userIds = comments.Select(c => c.UserId).Distinct().ToList();

            // 4. Kullanıcı bilgilerini tek seferde getir
            var users = (await _userRepository.GetAllAsync()) // Veya GetByIdsAsync varsa o kullanılır
                        .Where(u => userIds.Contains(u.Id))
                        .ToDictionary(u => u.Id); // ID ile hızlı erişim için

            // 5. Yorumları DTO'ya çevirirken kullanıcı adlarını ekle
            var commentDtos = comments.Select(comment =>
            {
                var dto = _mapper.Map<SupportRequestCommentDto>(comment);
                if (users.TryGetValue(comment.UserId, out var user))
                {
                    dto.Username = user.Username;
                }
                else
                {
                    dto.Username = "Bilinmeyen Kullanıcı"; // Kullanıcı silinmişse
                }
                return dto;
            }).ToList();

            // 6. Sayfalama (varsa)
            // commentDtos = commentDtos.Skip(...).Take(...).ToList();

            // 7. Sonucu döndür
            return commentDtos;
        }
    }
}
\end{lstlisting}

\newpage 

\section{AutoMapper Yapılandırması: Tercümanı Ayarlamak (\texttt{MappingProfile.cs})}

Hatırlarsak, AutoMapper bizim "tercümanımızdı" ve farklı sınıflar (örn: Entity ve DTO) arasında otomatik veri kopyalama (mapleme) işini yapıyordu. Ancak AutoMapper'ın bu işi yapabilmesi için ona \textbf{hangi sınıfın hangisine nasıl çevrileceğini} öğretmemiz gerekiyor.

Bu öğretme işlemini projemizdeki \texttt{MappingProfile.cs} dosyasında yapıyoruz. Bu dosya genellikle \texttt{Application} katmanının ana dizininde veya \texttt{Mapping} gibi bir alt klasörde bulunur.

Temel mantık şudur:
\begin{itemize}
    \item \texttt{Profile} sınıfından miras alan bir sınıf oluştururuz (genellikle adı \texttt{MappingProfile} olur).
    \item Bu sınıfın \textbf{yapıcı metodunun (constructor)} içine, tüm çeviri kurallarını \texttt{CreateMap<KaynakTip, HedefTip>()} kullanarak tanımlarız.
\end{itemize}

İşte projemizdeki \texttt{MappingProfile.cs} dosyasının içeriği ve açıklamaları:

\begin{lstlisting}[language=C#]
using AutoMapper; // AutoMapper kütüphanesini kullanabilmek için
// Aşağıdaki "using" satırları, maplemek istediğimiz tüm sınıfların
// (Command'lar, DTO'lar, Entity'ler) bulunduğu namespace'leri ekler.
using SupportRequestManagement.Application.Features.User.Commands;
using SupportRequestManagement.Application.Features.User.Dtos;
using SupportRequestManagement.Application.Features.SupportType.Commands;
using SupportRequestManagement.Application.Features.SupportType.Dtos;
using SupportRequestManagement.Application.Features.SupportRequestComment.Commands;
using SupportRequestManagement.Application.Features.SupportRequestComment.Dtos;
using SupportRequestManagement.Domain.Entities; // SupportType entity

// Bu namespace projenizin yapısına göre farklılık gösterebilir.
namespace SupportRequestManagement.Core.Application.Mapping 
{
    // AutoMapper'ın Profile sınıfından kalıtım alıyoruz.
    public class MappingProfile : Profile
    {
        // Yapıcı Metot (Constructor): AutoMapper başlatıldığında burası çalışır.
        public MappingProfile()
        {
            // === 1. User (Kullanıcı) Maplemeleri ===
            
            // User Entity'si ile UserDto arasında çift yönlü mapleme tanımlıyoruz.
            // Kaynak: User, Hedef: UserDto
            // .ReverseMap() sayesinde Hedef: UserDto, Kaynak: User map'lemesi de otomatik oluşur.
            CreateMap<User, UserDto>().ReverseMap(); 
            
            // CreateUserCommand'dan User Entity'sine mapleme.
            // Kaynak: CreateUserCommand, Hedef: User
            CreateMap<CreateUserCommand, User>()
                // .ForMember: Belirli bir hedef alan (dest: destination) için özel kural tanımlar.
                // Hedefteki `PasswordHash` alanı için (dest => dest.PasswordHash),
                // Kaynaktan gelen değeri yok say (opt: options => opt.Ignore()).
                // Çünkü PasswordHash'i Handler'da biz oluşturacağız.
                .ForMember(dest => dest.PasswordHash, opt => opt.Ignore()); 
            
            // UpdateUserCommand'dan User Entity'sine mapleme.
            // Kaynak: UpdateUserCommand, Hedef: User
            CreateMap<UpdateUserCommand, User>()
                 // Güncelleme sırasında Username değiştirilmeyecek, ignore et.
                 .ForMember(dest => dest.Username, opt => opt.Ignore()) 
                 // Şifre bu komutla değiştirilmeyecek, ignore et.
                 .ForMember(dest => dest.PasswordHash, opt => opt.Ignore()) 
                 // Oluşturulma tarihi (CreatedAt) asla güncellenmemeli, ignore et.
                 .ForMember(dest => dest.CreatedAt, opt => opt.Ignore()); 

            // === 2. SupportType (Destek Tipi) Maplemeleri ===
            CreateMap<SupportType, SupportTypeDto>().ReverseMap(); // Entity <-> DTO
            CreateMap<CreateSupportTypeCommand, SupportType>(); // Command -> Entity
            CreateMap<UpdateSupportTypeCommand, SupportType>(); // Command -> Entity

            // === 3. SupportRequestComment (Yorum) Maplemeleri ===
            
            // SupportRequestComment (Entity) -> SupportRequestCommentDto
            CreateMap<SupportRequestComment, SupportRequestCommentDto>()
                // DTO'daki `Username` alanı Entity'de yok.
                // Bu alanı Handler'da dolduracağımız için Mapper bunu ignore etsin.
                .ForMember(dest => dest.Username, opt => opt.Ignore()); 
            
            // SupportRequestCommentDto -> SupportRequestComment (Entity)
            // .ReverseMap() yerine bu şekilde ayrı tanımlamak bazen daha nettir.
            // Şu an bu yönde bir çeviri yapmıyoruz ama ileride gerekebilir.
            CreateMap<SupportRequestCommentDto, SupportRequestComment>(); 
                
            // CreateSupportRequestCommentCommand -> SupportRequestComment (Entity)
            CreateMap<CreateSupportRequestCommentCommand, SupportRequestComment>();

            // === 4. Diğer Özelliklerin Maplemeleri ===
            // Eğer projenizde SupportRequest, SupportCategory, Notification gibi 
            // başka özellikler varsa, onların Command, DTO ve Entity'leri arasındaki
            // çeviri kuralları da buraya benzer şekilde eklenmelidir.
            // Örnek:
            // CreateMap<SupportRequest, SupportRequestDto>().ReverseMap();
            // CreateMap<CreateSupportRequestCommand, SupportRequest>();
            // CreateMap<Notification, NotificationDto>();
            // ... vb.
        }
    }
}
\end{lstlisting}

\section{Sonuç}

Bu dokümanda, \texttt{SupportRequestManagement.Application} katmanındaki \texttt{User}, \texttt{SupportType} ve \texttt{SupportRequestComment} özelliklerinin kodlarını adım adım inceledik. CQRS deseni, MediatR, Repository Pattern ve AutoMapper gibi araçların nasıl kullanıldığını basit bir dille anlatmaya çalıştık. Unutulmaması gereken en kritik nokta, özellikle kullanıcı oluşturma işlemindeki şifre hashleme adımının güvenli bir şekilde tamamlanmasıdır.

Umarım bu detaylı anlatım, projenin bu bölümünü anlamanıza yardımcı olmuştur!

\end{document}
